#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright 2014 Jan-Philip Gehrcke (http://gehrcke.de).
# See LICENSE file for details.

"""
JS from
https://raw.github.com/twbs/bootstrap/v3.1.1/dist/js/bootstrap.min.js

CS from
...

"""

from __future__ import unicode_literals


import sys
import os
import re
import shutil
import logging
from collections import OrderedDict
from string import Template
from subprocess import Popen, PIPE
import urllib
try:
    import HTMLParser as htmlparser
except ImportError:
    import html.parser as htmlparser

import conf


DOCUTLSTMPL = "resources/docutils_template.txt"
BUILDDIR = "_build"
HTMLTMPL = "resources/index.html.tpl"


log = logging.getLogger()
log.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
formatter = logging.Formatter(
    '%(asctime)s,%(msecs)-6.1f - %(levelname)s: %(message)s',
    datefmt='%H:%M:%S')
ch.setFormatter(formatter)
log.addHandler(ch)


class BodyFilterError(Exception):
    """Error class for all kind of issues during body filtering."""
    pass


class BodyFilter(object):
    """A filter for modifying the HTML code as returned by
    rst2html or markdown.
    """
    def __init__(self):
        pass

    def process(self, body):
        """_process must be implemented by children."""
        if not body:
            raise BodyFilterError("body is empty: %s" % body)
        log.debug("Body is about to be filtered by %s.", self.__class__.__name__)
        log.debug("Prefilter body length: %s", len(body))
        b = self._process(body)     
        log.debug("Filter done. Postfilter body length: %s", len(b))
        return b


class DocutilsTitleFilter(BodyFilter):
    """Remove <h1 class="title">xxx</h1>.

    This program adds its own title. Hence, if docutils also adds a
    title, this filter removes it. Yes, in general we should not use 
    RegEx for filtering HTML. In this case, however, it's not *any*
    HTML, it is *the* HTML as generated by docutils, and it is the
    first line and the first tag in the document. So we really do not
    anticipate the entire universe of HTML, and that's why RegEx is
    fine.
    """
    def _process(self, body):
        bodylines = body.splitlines()
        first = bodylines[0]
        if not "h1" in first:
            log.info("No h1 in first line of body. Skip.")       
            return body
        match = re.search('<h1 class="title">.*</h1>', first)
        if not match:
            raise BodyFilterError("First line contains h1, but does not match pattern.")
        log.info('First line contains docutils title (<h1 class="title">...</h1>). Remove.')
        return "\n".join(bodylines[1:])


def heading_to_label(heading):
    log.debug("Converting '%r' to label.", heading)
    # First, decode HTML entities:
    h = htmlparser.HTMLParser().unescape(heading)
    log.debug("Unescaped heading: %r", h)
    # Then, split at whitespace, then get rid of all
    # non-alphanumeric chars in each token and reconnect with "-".
    cleantokens = (re.sub('[^0-9a-zA-Z]+', '', s).lower() for s in h.split())
    return "toc-" + "-".join(t for t in cleantokens if t)


def auto_toc_from_h1(body):
    label_heading_dict = OrderedDict()
    def replace_heading(matchobj):
        heading = matchobj.group(1)
        label = heading_to_label(heading)
        log.info("Found heading: %r", heading)
        rpl = '<h1 id="%s">%s</h1>' % (label, heading)
        log.info("Replacing with: %r", rpl)
        # Save correspondence for later.
        label_heading_dict[label] = heading
        return rpl

    log.info("Scanning body for <h1>*</h1>, replacing on the fly.")
    body = re.sub("<h1>(.*)</h1>", replace_heading, body)

    # Validation of anchors: should be unique!
    # First check within the newly created labels.
    labels = label_heading_dict.keys()
    if len(set(labels)) != len(labels):
        log.error("Duplicate headline. Must be unique, abort.")
        sys.exit(1)
    
    listitems = []
    for label, heading in label_heading_dict.items():
        listitems.append('<li><a href="#%s">%s</a></li>' % (label, heading))
    listhtml = "\n".join(listitems)
    log.debug("Generated the following toc list:\n%s", listhtml)
    prefix = """
<div class="sidebar-module">
<h4>Contents</h4>
<ol class="list-unstyled">\n"""
    suffix = '\n</ol></div>'
    toc = "\n".join([prefix, listhtml, suffix])
    return body, toc
 

def main():
    # Read basic HTML scaffold.
    log.info("Read HTML template from %s", HTMLTMPL)
    with open(HTMLTMPL, "rb") as f:
        htmltpl = Template(f.read().decode("utf-8"))

    # (Re-)create build directory.
    log.info("Create build directory.")
    if os.path.isdir(BUILDDIR):
        shutil.rmtree(BUILDDIR)
        os.mkdir(BUILDDIR)
    shutil.copytree("resources/static", os.path.join(BUILDDIR, "static"))

    # Create document body: convert body source (rst, markdown) to HTML.
    log.info("Create document body: convert source to HTML.")
    bodysourcefilepath = sys.argv[1]
    args = [
        "rst2html.py",
        "--template=%s" % DOCUTLSTMPL,
        bodysourcefilepath
        ]
    log.debug("Subprocess details: %s", args)
    sp = Popen(args, stdout=PIPE, stderr=PIPE)
    bodyconverter_out, bodyconverter_err = sp.communicate()
    if sp.returncode != 0:
        log.error("Subprocess exitcode: %s", sp.returncode)
        log.info("Subprocess stderr:\n%s", bodyconverter_err)
        log.info("Exit with code 1.")
        sys.exit(1)

    # Filter body.
    body = bodyconverter_out        
    bodyfilter = [DocutilsTitleFilter()]
    for bfilter in bodyfilter:
        body = bfilter.process(body)

    body, toc = auto_toc_from_h1(body)

    # Prepare GA snippet if requested by config.
    ga_snippet = ""
    if conf.googleanalytics_id:
        log.info("Prepare Google Analytics snippet with ID %s",
            conf.googleanalytics_id)
        ga_snippet = Template(GA_SNIPPET).substitute(
            googleanalytics_id = conf.googleanalytics_id)

    # Create HTML document: fill basic HTML template.
    log.info("Create main HTML document (fill template).")
    template_mapping = {
        "title": conf.title,
        "description": conf.description,
        "body": body,
        "about": conf.about,
        "copyright": conf.copyright,
        "sidebar": conf.sidebar + "\n" + toc,
        "googleanalytics": ga_snippet,
        }
    htmlout = htmltpl.substitute(template_mapping)


    # Write HTML document.
    indexhtmlpath = os.path.join(BUILDDIR, "index.html")
    log.info("Write %s.", indexhtmlpath)
    with open(indexhtmlpath, "wb") as f:
        f.write(htmlout.encode("utf-8"))


# Define GA snippet. Official version from
# https://developers.google.com/analytics/devguides/collection/gajs/asyncTracking
# TODO: use optimized versin from HTML5 boilerplate project:
# https://github.com/h5bp/html5-boilerplate/issues/1444
GA_SNIPPET = """
<script type="text/javascript">
  var _gaq = _gaq || [];i
  _gaq.push(['_setAccount', '$googleanalytics_id']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
"""


if __name__ == "__main__":
    main()


